- [04章 抽象](#04----)
- [05 插叙：进程API](#05------api)
- [07 进程调度](#07-----)
- [08 多级反馈队列](#08-------)
- [09 调度 比例份额](#09--------)
- [14 插叙 内存操作API](#14--------api)
- [15 机制 地址转换](#15--------)
- [16  分段](#16----)
- [17 空闲空间管理](#17-------)
- [18 分页 介绍](#18------)
- [19 分页 快速地址转换（TLB）](#19-----------tlb-)
- [22 超越物理内存 策略](#22----------)

# 04章 抽象

作业

1. CPU利用率100%，因为只有CPU在运行，没有I/O操作.



2. 10个操作，结果如图：

![image-20201218101646257](.images/image-20201218101646257.png)

3. 现在效率提高了，因为在等待I/O操作的同时，进行了CPU操作。

![image-20201218101828850](.images/image-20201218101828850.png)

4. 此时CPU浪费了，因为I/O操作的时候，CPU没有进行有效操作。

![image-20201218102051348](.images/image-20201218102051348.png)

5. 现在效率提高了，因为在等待I/O操作的同时，进行了CPU操作

![image-20201218102119868](.images/image-20201218102119868.png)

6. 

![image-20201218102605884](.images/image-20201218102605884.png)

7.  当I/O完成时，会立即运行发出它的进程，这样的效率也会更高

![image-20201218102814416](.images/image-20201218102814416.png)

8. 当采用$-S \ SWITCH\_ON\_IO$标志时，进程运行I/O操作时，会切换到另一个进程，此时可以更好的利用CPU.

   当采用$-I \ IO\_RUN\_IMMEDIATE$标志时，当I/O完成时，会立即运行发出它的进程，这样的效率也会更高，因为发出I/O的进程很可能还会有I/O操作需要进行，因此这样效率更高。



# 05 插叙：进程API

![image-20201218110805311](.images/image-20201218110805311.png)

​	代码：

![image-20201218133203111](.images/image-20201218133203111.png)

​        结果：

![image-20201218133224003](.images/image-20201218133224003.png)

​         子进程和父进程改变值时，它们各自改变，相互不影响。

![image-20201218133313135](.images/image-20201218133313135.png)

![image-20201218144145600](.images/image-20201218144145600.png)

​                          父子进程访问同一个文件描述符，父子进程都会在同一个文件中写入。

![image-20201218144202465](.images/image-20201218144202465.png)

![image-20201218150616585](.images/image-20201218150616585.png)

​                         可以通过文件描述符来作为父子通信的桥梁，从而不使用wait，也可以保证父子进程的运行顺序。





![image-20201218151503961](C:\Users\maoch\AppData\Roaming\Typora\typora-user-images\image-20201218151503961.png)

![image-20201218151454142](.images/image-20201218151454142.png)



![image-20201218151529021](.images/image-20201218151529021.png)

​                     父进程返回子进程的进程号，子进程返回0

![image-20201218151820936](.images/image-20201218151820936.png)

​                      waitpid是可以等待确定的子进程结束。而不是任意一个子进程进程结束，当父进程有多个子进程时，waitpid可以起作用。





![image-20201218152458705](.images/image-20201218152458705.png)

​                     将不会有任何输出内容。



![image-20201218154950498](.images/image-20201218154950498.png)

![image-20201218154943226](.images/image-20201218154943226.png)

# 07 进程调度

见书

# 08 多级反馈队列

![image-20201219101108517](.images/image-20201219101108517.png)

![image-20201219101117952](C:\Users\maoch\AppData\Roaming\Typora\typora-user-images\image-20201219101117952.png)

![image-20201219101131257](C:\Users\maoch\AppData\Roaming\Typora\typora-user-images\image-20201219101131257.png)

![image-20201219101141138](C:\Users\maoch\AppData\Roaming\Typora\typora-user-images\image-20201219101141138.png)

![image-20201219101158857](C:\Users\maoch\AppData\Roaming\Typora\typora-user-images\image-20201219101158857.png)

2. 

![image-20201219113020196](.images/image-20201219113020196.png)

 规则4a和4b,结果：

![image-20201219113045755](.images/image-20201219113045755.png)

![image-20201219113102901](.images/image-20201219113102901.png)

 每50ms提升优先级结果：

![image-20201219113136197](.images/image-20201219113136197.png)

  不采用时间片，而是采用队列配额：

![image-20201219113223125](.images/image-20201219113223125.png)

  结果：

![image-20201219113301308](.images/image-20201219113301308.png)



# 09 调度 比例份额

1. 

![image-20201219115242164](C:\Users\maoch\AppData\Roaming\Typora\typora-user-images\image-20201219115242164.png)

![image-20201219115258725](.images/image-20201219115258725.png)

2. 

![image-20201219115310016](.images/image-20201219115310016.png)

![image-20201219115453538](.images/image-20201219115453538.png)

​                   工作0可能会运行，从平均的角度来看会运行0.1个时间片，会造成饥饿。



3. 

![image-20201219115836382](.images/image-20201219115836382.png)

​           不公平因子基本趋近于1，比较公平。





# 14 插叙 内存操作API 

1. 

![image-20201219120345806](.images/image-20201219120345806.png)

![image-20201219121736850](.images/image-20201219121736850.png)

​                          运行时，什么都没有发生。

2. 

![image-20201219121657682](.images/image-20201219121657682.png)

![image-20201219122546900](.images/image-20201219122546900.png)

​						显示正常退出。



3. 

![image-20201219123016000](.images/image-20201219123016000.png)

![image-20201219123007913](.images/image-20201219123007913.png)

​						结果显示free没有执行，因此可知释放NULL指针的代码在编译器中进行了优化，没有执行free函数。

4. 

![image-20201219164103496](.images/image-20201219164103496.png)

![image-20201219164257569](.images/image-20201219164257569.png)

 				运行时不会报错，用gdb也不会报错，但是个valgrind可以发现有内存泄漏

![image-20201219164220451](.images/image-20201219164220451.png)

5.  

![image-20201219164818928](.images/image-20201219164818928.png)

![image-20201219165008812](.images/image-20201219165008812.png)

​					运行时，这个程序不会报错。当使用valgrind时，可以发现该程序有一个错误的写和内存泄漏。

![image-20201219164811738](.images/image-20201219164811738.png)

6.

![image-20201219165116461](.images/image-20201219165116461.png)

​						运行时不会报错, 用valgrind发现有一个错误的写。

![image-20201219165108711](.images/image-20201219165108711.png)



7.

![image-20201219165624710](.images/image-20201219165624710.png)

![image-20201219165700041](.images/image-20201219165700041.png)

​						此时直接在编译过程中就会报错。

![image-20201219165614644](.images/image-20201219165614644.png)



# 15 机制 地址转换

见书上



# 16  分段

见书上



# 17 空闲空间管理

1. 

![image-20201220102239572](.images/image-20201220102239572.png)

![image-20201220110816570](.images/image-20201220110816570.png)

2. 

![image-20201220110831464](.images/image-20201220110831464.png)

![image-20201220110906713](.images/image-20201220110906713.png)

​							碎片变多了，能分配的最大块的容量减少了。



3. 

![image-20201220111019544](.images/image-20201220111019544.png)

![image-20201220111042480](.images/image-20201220111042480.png)

搜索空闲块的时间变快了，不需要遍历整个空闲链表，只需要找到第一个满足的空闲块即可。

4

![image-20201220112138621](.images/image-20201220112138621.png)

​		对于首次适配方法而言，SIZESORT排序是最快的，因为此时可以大大减少搜索空闲块的时间。

5

![image-20201220111311299](.images/image-20201220111311299.png)

不合并：

![image-20201220111650169](.images/image-20201220111650169.png)

合并：

![image-20201220111525259](.images/image-20201220111525259.png)

明显不合并碎片数量增大，而且空闲列表的分配量也会增大，因为碎片太小不能满足分配需求，所以需要从堆上继续分配空间。



# 18 分页 介绍

1. 

![image-20201220192251495](.images/image-20201220192251495.png)

​				页表大小随着地址空间的增长而增长。 随着页面大小的增大而减少。

​				因为 页表大小 ×  页大小 ==  地址空间。

​				当使用较大的页时，容易产生内部碎片，而且每次加载页时时间也会变长。



2. 

![image-20201220192505440](.images/image-20201220192505440.png)

会使得虚拟地址能更多的有效映射到物理内存区域，也就是可使用的虚拟地址空间增多。

-u 0

![image-20201220192932236](.images/image-20201220192932236.png)

-u 100

![image-20201220192916326](.images/image-20201220192916326.png)

3.

![image-20201220192953239](.images/image-20201220192953239.png)

第一组页的大小太小，不容易存储有效数据。

第三组页的大小太大， 容易造成内部碎片。

4

![image-20201220193912268](.images/image-20201220193912268.png)

当地址空间大于物理内存时，有些页数据可以交换到磁盘上，这取决于交换空间容量的限制。



# 19 分页 快速地址转换（TLB）

1.

![image-20201220203733306](.images/image-20201220203733306.png)

还是只需要一个寄存器李定位页目录。

2.

![image-20201220203804826](.images/image-20201220203804826.png)

需要三次内存引用，第一次是页目录页，第二次是页表页，第三次是数据。

3

![image-20201220210021930](.images/image-20201220210021930.png)

缓存页表中的页表项



# 22 超越物理内存 策略

1. 

![image-20201220211444231](.images/image-20201220211444231.png)

OPT策略最佳，LRU次之， FIFO再次



2. 

![image-20201220211851020](.images/image-20201220211851020.png)

对于FIFO策略：构造0,1,2,3,4,5,0,1,2,3,4,5序列即可

![image-20201220211843630](.images/image-20201220211843630.png)

此时采用OPT策略为：

![image-20201220211959584](.images/image-20201220211959584.png)

而继续采用FIFO策略，缓存增加为6即可：

![image-20201220212036626](.images/image-20201220212036626.png)



对于LRU策略：也同FIFO策略一样。

补充：

![image-20201220212327897](.images/image-20201220212327897.png)

![image-20201220212342593](.images/image-20201220212342593.png)

缓存增大时：命中率反而下降

![image-20201220212356459](.images/image-20201220212356459.png)

![image-20201220212413192](.images/image-20201220212413192.png)



3. 

![image-20201220212525078](C:\Users\maoch\AppData\Roaming\Typora\typora-user-images\image-20201220212525078.png)



![image-20201220212508858](.images/image-20201220212508858.png)

对于随机序列的负载，任何策略的效果都基本一样，除了OPT，它们的命中率都只与缓存容量大小有关，与策略无关。这也很好理解，因为随机序列无法根据历史信息预测未来，因此LRU算法也会失效。



4. 

![image-20201220212937147](.images/image-20201220212937147.png)

![image-20201220212849053](.images/image-20201220212849053.png)

CLOCK时钟位越多，保留的历史信息越多，越趋近于LRU。